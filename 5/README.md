# Пренасочване на стандартния вход и изход
(записки към петото упражнение)

Употреба на `close(2)`, `dup(2)` и `dup2(2)` за целта.

## `dup(2)` и `dup2(2)`

    #include <unistd.h>

    int dup(int oldfd);
    int dup2(int oldfd, int newfd);

Системното извикване `dup()` създава копие на файловия дескриптор `oldfd`, използвайки незаетия файловия дескриптор с най-малък номер.

След като `dup()` успешно върне резултат, двата дескриптора могат да се използват един вместо друг.  Те сочат към един и същ __запис за отворен файл__ (виж
`open(2)`), и затова имат едно и също описание на отворения файл (съответно и една и съща текуща позиция във файла): например ако позицията в файла бъде променена чрез `lseek(2)` през един от дескрипторите, то тя автоматично ще се промени и за другия.

Не всички флагове от `oldfd` са налични при копирания файлов дескриптор (например `FD_CLOEXEC` не е).  Освен това е важно да се спомене, че файлът се затваря (т.е. описанието му се затваря), когато се затвори последният файлов дескриптор, свързан с него.

При успешно копиране `dup()` връща новия файловия дескриптор.  При грешка `lseek()` връща стойност `-1` и номерът на грешката се задава в `errno`.

### `dup2()`

Извикването `dup2()` прави (и връща) същото като `dup()`, но вместо да използва най-малкия файлов дескриптор, то използва дескриптора, зададен в аргумента `newfd`.  Ако той е бил отворен преди това, то той автоматично се затваря (т.е. извиква му се `close(2)`), преди да бъде преизползван.  Това е важно, тъй като имплементирането на еквивалента на тази функционалност чрез извикванията `close(2)` и `dup(2)` може да доведе до състезания (т.нар. *race conditions*), ако `newfd` се преизползва за нещо друго между двете стъпки.  Такова нещо може да се случи например при прекъсване на програмата от функция, обслужваща сигнал, който отваря съответния файлов дескриптор, или ако дескрипторът бъде отворен в друга нишка.

Важно е да се спомене, че:
* Ако `oldfd` не е валиден файлов дескриптор, то извикването директно ще върне грешка и `newfd` няма да бъде затворен.
* Ако `oldfd` не е валиден файлов дескриптор, но е същият като `newfd`, то `dup2()` няма да направи нищо, а просто ще върне `newfd`.

## Задачи

1. Изведете файл, подаден като аргумент на командния ред, използвайки пренасочване на стандартния вход.
2. Запишете подаденото на стандартния вход във файл, подаден като аргумент, използвайки пренасочване на стандартния изход.
3. Защо output-ът на следната програма е `Gidday world`?  Обосновете отговора си.

        #include <unistd.h>
        #include <fcntl.h>

        int main(int argc, const char* const* argv)
        {
            if (argc < 2)
                exit(1);

            int fd1 = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
            int fd2 = dup(fd1);
            int fd3 = open(argv[1], O_RDWR);
            write(fd1, "Hello,", 6);
            write(fd2, " world", 6);
            lseek(fd2, 0, SEEK_SET);
            write(fd1, "HELLO,", 6);
            write(fd3, "Gidday", 6);
            return 0;
        }