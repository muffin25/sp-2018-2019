# Проекти

Всички задания за проекти включват имплементацията на стандартни Unix команди.  Описанието на всяка команда е разделено на три части:

* какво точно трябва да прави командата (как трябва да се държи);
* какви аргументи (задължителни и опционални) трябва да поддържа командата;
* възможно е да има допълнителни насоки за това как е най-лесно/най-добре да се имплементира командата.

От студентите се очаква да имплементират командите на езика C.

## Срок

Проектите трябва да бъдат предадени като *pull request* към репото (или имейл на `rgeorgiev583@gmail.com`) до 27.01. включително.

## Видове

Има три вида команди, които могат да се избират като задания за проект (разделението е по трудност):

* с ниска трудност (лесни): `nologin`, `pwdx`, `yes`;
* с нормална трудност: `expand`, `kill`, `nl`, `seq`, `strings`, `unexpand`;
* с висока трудност (трудни): `fold`, `paste`, `sysctl`, `tr`.

## Избор на задание за проект

Всеки студент има три варианта за избор на задание за проект:

1. да имплементира **три** лесни команди;
2. да имплементира **две** команда с нормална трудност;
3. да имплементира **една** трудна команда.

Изборът на команди е свободен и не е ограничен по брой студенти на команда.

## Предаване

Предаването на имплементациите на проектите се случва чрез *pull request* към това репо.  Файловете, които се добавят чрез *pull request*-а, трябва да се намират в поддиректорията `projects/ФН/`, където *ФН* е факултетният номер на студента.

Обикновено е достатъчно в *pull request*-а да има по един файл за всяка имплементация на команда в горепосочената директория.  Файловете трябва да се казват така, както е зададено името на командата.

Възможно е проектите да бъдат предадени и чре имейл на `rgeorgiev583@gmail.com`, към който са прикачени файловете с имплементациите на командите.

Например ако студент с факултетен номер `81030` е избрал да имплементира командите `nologin`, `pwdx` и `yes`, *pull request*-ът трябва да съдържа директория `projects/81030` и следните файлове:
* `projects/81030/nologin.c`;
* `projects/81030/pwdx.c`;
* `projects/81030/yes.c`.

## Оценяване

Оценката на всеки един проект е между **Слаб (2)** и **Отличен (6)** и се оформя в зависимост от това какво задание е избрал студентът.  Тя се образува, като се вземе средноаритметичното от оценките за всяка една команда в рамките на заданието.

Оценката за имплементирана команда отново варира между **Слаб (2)** и **Отличен (6)** и се образува на базата на следните критерии, като за всеки от тях се заделя приблизително една единица от оценката:
* *функционалност*: каква част от описанието командата е имплементирана;
* *коректност*: доколко е имлементирана по правилен начин функционалността на командата;
* наличие на проверки за грешки;
* стил на кода.

Ако част от условието е описана като *бонус*, тя няма да влиза в основната оценка, а ще я допълва (т.е. ще е възможно студентът да има максимална оценка, дори тази част да не е имплементирана).

## Общи насоки за имплементация на проектите

* Всички зададени команди могат да бъдат имплементирани без алокация на динамична памет посредством `malloc(3)`.  Възможно е да се наложи да създавате статични буфери с фиксиран размер на стека или като глобални променливи, но не би трябвало да се ви се наложи да правите алокации на памет.

* Всички зададени команди могат да бъдат имплементирани без буфериране на прочетените данни от входа (т.е. във всеки случай входните данни могат да се обработват символ по символ).  Поради тази причина е желателно за въвеждане и извеждане да се използват функциите от `<stdio.h>` (за буферирано I/O) вместо тези от `<unistd.h>` (за небуферирано I/O):

    * `fopen(3)` вместо `open(2)`;
    * `getc(3)` вместо `read(2)`;
    * `putchar(3)`, `putc(3)`, `puts(3)` и `fputs(3)` вместо `write(2)`.

    Естествено, командите биха могли да бъдат имплементирани по работещ начин и чрез `open(2)`, `read(2)` и `write(2)`, но с известна загуба на производителност.  Тъй като за целите на проекта се интересувами командите просто да работят, такъв вид решение също е приемливо.

* Не смесвайте функциите за буферирано и небуферирано I/O за определен файлов дескриптор и съответстващия му `FILE` буфер.  Например не трябва да се смесват извиквания на `write(2)` с аргумент файловия дескриптор на стандартния изход (`STDOUT_FILENO`) и извиквания на `fputs(3)` с аргумент буфера за стандартния изход (`stdout`).

* Използвайте ключовата дума `static` за глобални променливи, както и за функции, различни от `main`.  Самите глобални променливи може да използвате за съхраняване на прочетените и разпознати стойности на опциите.  Ако командата приема повече от един файл като аргумент, е добре да имате функция с имплементацията на самата функционалност на командата, която да се извиква в `main`.  Обикновено е достатъчно като аргумент на тази функция да се подаде файлов дескриптор, от който да чете (като стойностите на опциите се взимат от съответните глобални променливи).

* Старайте се да имплементирате командите по най-простия възможен начин, без да си усложнявате живота.  Това е общо взето целта на занятието.

## Допълнителна информация

### Описания на командите

Всяка команда е описана във файл в поддиректорията `projects` с името на командата и разширение `.md` (например за командата `echo` файлът с описанието се казва `echo.md`).  Насоки за работа с опционалните аргументи и за това как те могат да се имплементират може да откриете във файла `OPTIONS.md`.  Примери за това как се използват (и съответно как може да се тестват) командите са дадени в поддиректорията `examples` на `projects`.

### Комадни редове

Обозначават как точно се извиква командата (с какви аргументи).  В описанията се използва следният синтаксис:

* низ от малки букви: обозначава нещо, което на това място се среща буквално (например името на командата или опция);
* низ от главни букви: обознава нещо, което на това място трябва да се замести с дадена стойност (например задължителен аргумент или аргумент на опция);
* `[FOO]`: означава, че на това място `FOO` не е задължително да го има;
* `FOO...`: означава, че на това място `FOO` може да се среща веднъж или повече пъти;
* `[FOO]...`: означава, че на това място `FOO` може да се среща нула или повече пъти;
* `FOO|BAR`: означава, че на това място може да се срещне `FOO` или `BAR`.

Ако са изброени няколко различни командни реда, те се считат за алтернативни извиквания на командата.

### Компилиране на командите

Използвайте `cc ИМЕ.c -o ИМЕ`, за да компилирате изходния файл с имплементацията на командата.  Целта е изпълнимият файл да носи името ѝ.

Ако смятате да дебъгвате чрез `gdb`, трябва да използвате `-g` флага при компилация: `cc -g ИМЕ.c -o ИМЕ`.

За по-голямо удобство вместо да извиквате `cc` директно, можете да използвате поставения в тази директория `Makefile`.  Достатъчно е да го копирате при файла с имплементацията и да изпълните командата `make`.  Ако пък искате да изчистите генерираните файлове при компилацията, може да извикате `make clean`.

### Изпълнение на командите

Използвайте `./ИМЕ`, за да изпълните командата.
